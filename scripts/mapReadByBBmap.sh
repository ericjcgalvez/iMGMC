#!/bin/bash
# mapping reads to ORF of iMGMC-GeneID.fasta
# need ~32memory, use all logical cors
# use ./mapReadsByBBmap.sh LibrayType SampleID FastqPath [FastqPathR2]
# index have to be already processed

# determinate iMGMC install PATH
tput setaf 1; echo $0; tput sgr0

#echo
echo "$iMGMCPATH"
#iMGMCPATH=${0%/scripts*}

#echo $iMGMCPATH
echo $0 $1 $2 $3 $4
LibrayType=$1
SampleID=$2
FastqPath=$3
FastqPathR2=$4

#Cores to use
Cores=10


#Ref for bbmap generated by "bbmap.sh ref=iMGMC-GeneID.fasta.gz"
Ref="${iMGMCPATH}/"
Ref16S=${iMGMCPATH}/ref-16S

# will treat paired libraries like single end reads, to allow reads to hit two genes
if [ "$LibrayType" == "DNAunpaired" ]
	then
	if [ -z "$FastqPathR2" ]
		then
		echo "Start mapping for ${SampleID} with pair-end reads in single-end mode: ${FastqPath} and ${FastqPathR2}"
		bbmap.sh threads=${Cores} path=${Ref} in=${FastqPath} in2=${FastqPathR2} interleaved=f covstats=${SampleID}.covstats statsfile=${SampleID}.statsfile
		else
		echo "Start mapping for ${SampleID} with interleave reads in single-end mode: ${FastqPath}"
		bbmap.sh threads=${Cores} path=${Ref} in=${FastqPath} in2=${FastqPathR2} interleaved=f covstats=${SampleID}.covstats statsfile=${SampleID}.statsfile
	fi
	echo "Mapping done"
	exit
fi

#standard mapping for RNA/DNA - stranded reads option will only use for TPM caculation
if [ -z "$FastqPathR2" ]
	then
	echo "Start mapping for ${SampleID} with single-end Reads: ${FastqPath}"
	bbmap.sh threads=${Cores} path=${Ref} in=${FastqPath} covstats=${SampleID}.covstats statsfile=${SampleID}.statsfile
	else
	echo "Start mapping for ${SampleID} with pair-end Reads: ${FastqPath} and ${FastqPathR2}"
	bbmap.sh threads=${Cores} path=${Ref} in=${FastqPath} in2=${FastqPathR2} covstats=${SampleID}.covstats statsfile=${SampleID}.statsfile
fi

echo "Mapping done"

